# Описание реализации алгоритма поиска маршрута
## 1. Логика получения карты
  Карту получаем из файла, в котором определенными символами обозначаем разрешенные и не разрешенные для прохода клетки.
  Считаем, что карта у нас прямоугольная, поэтому число символов в каждой строчке должно быть одинаковым. Символом (*) обозначаем запрещенные для прохода клетки. Символом (0) обозначаем разрешенные для прохода клетки.
  При парсинге файла с картой посчитать количество строк (m) и столбцов (n) в файле, завести массив int размером (m+2)x(n+2).
  Края массива заполнить значениями "-1" (для того чтобы при поиске маршрута не проверять наличие края карты).
  Заполняем массив(начиная с индекса 1) в соответствии с тем что получаем из файла: клетки доступные для прохода заполняем нулями, в недоступные пишем -1.

## 2. Установка точки начала маршрута
  Точку начала (и конца) маршрута можно получить также из файла обозначив её символом (=) (конец обозначим (+)). Для хранения координат начала и конца маршрута заводим отдельные переменные
  
## 3. Заполнение карты для поиска маршрута
  В ячейку массива с координатами начальной точки кладём значение 1.
  Начинаем цикл, который будет длится до тех пор пока не найдётся конец маршрута, либо не останется нулевых ячеек в массиве. Каждый проход цикла будет обозначать номер волны (такта).
    Внутри цикла организовываем цикл с перебором ячеек массива в котором при нахождении ячейки с номером такта распространяем на соседнии нулевые ячейки значения номера такта+1.
  При выходе из всех циклов выясняем добрались ли мы до конечной точки маршрута или нет.
  Для ускорения процесса, чтобы каждый раз полностью не перебирать все ячейки массива, можно организовать очередь из заполненных в процессе заполнения ячеек массива и перебирать только их.
  
  Восстанавливаем маршрут (если его нашли) двигаясь от конца маршрута каждый раз в ячейку со значением меньшим на 1 и так до точки начала маршрута.
 
 ## 4. Решение для нескольких выходов
  Решение, в целом, будет такое же.
